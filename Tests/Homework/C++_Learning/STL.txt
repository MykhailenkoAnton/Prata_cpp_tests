О(нотация) - математическое обозначение сложности(скорости) алгоритма

Константная сложность О(1) (нахождение определенного елемента в массиве(контейнере))
пример: return arr[i]; то же самое что и return *(arr + i);
от времени не зависит, потому что добавляем к адресу индекс, разыминовываем и возващаем


Алгоритмическая О(log n)
бинарный поиск к примеру в бинарном дереве


Линейная сложность O(n)
время прямопропорционально зависит от количества елементов в массиве и т.д.
пример: std::cout << arr[i] , прохождение по всем елеменам массива пока i != arr[end]
так же с математическими операциями для всех елементов в массиве
линейный поиск == O(n/2) (уточнение)


О(n * long n)
Quick Sort

Квадратная сложность О(n ^ 2)
пример: Двухвымерный массив с одинаковым размером i and j, иначе скорость будет О(x * y)
сортировка выборочная, вставками, пузырьковая(самый лучший что может быть = O(n))

Кубическая сложность О(n ^ 3)
пример: цикл в цикле в цикле с одинаковым размером i and j, иначе скорость будет О(a * b * c)


======================================================================
ADT Абстрактные типы данных: 
Односвязный список, Двухсвязный список, Стек, Очеред, Бинарное дерево

======================================================================
STL : контейнеры, алгоритмы, итераторы, предикаты (функторы, алокаторы)

Итераторы = 
Библиотека итераторов предоставляет определения итераторов для пяти (до C++17)шести 
(начиная с C++17) видов, а также свойств итераторов, адаптеров и служебных функций.
Категории итераторов
Существует пять (до C++17)шесть (начиная с C++17) видов итераторов: 
LegacyInputIterator, LegacyOutputIterator, LegacyForwardIterator,
LegacyBidirectionalIterator, LegacyRandomAccessIterator и LegacyContiguousIterator (начиная с C++17).
Вместо того, чтобы определяться конкретными типами, каждая категория итераторов определяется операциями, 
которые могут быть выполнены с нею. Это определение означает, что любой тип, поддерживающий 
необходимые операции, может использоваться в качестве итератора – например, указатель поддерживает
все операции, требуемые для LegacyRandomAccessIterator, поэтому указатель можно использовать где угодно,
где ожидается LegacyRandomAccessIterator.
Все категории итераторов (кроме LegacyOutputIterator) могут быть организованы в иерархию, 
где более мощные категории итераторов (например, LegacyRandomAccessIterator) поддерживают операции менее
мощных категорий (например, LegacyInputIterator). Если итератор попадает в одну из этих категорий и также 
соответствует требованиям LegacyOutputIterator, то он называется изменяемым итератором и поддерживает ввод 
и вывод.
Неизменяемые итераторы называются константными итераторами.

итератор = Итератор — интерфейс, предоставляющий доступ к элементам коллекции(контейнера) и навигацию по ним.
Класс(шаблон класса), который имитирует указатель на елементы контейнера
были придуманны что бы мы могли писать функции, которые работают со всеми контейнерами одинаков

--------------------------------------------------------------------
Алгоритм (в контексте STL) это функции которая работает с контейнером через итератор
потому что итераторы предоставляют абстракцию по отношению ко всем контейнерам 
алгоритмы = Библиотека алгоритмов определяет функции для различных целей 
(например, поиск, сортировка, подсчёт, манипулирование), которые работают с диапазонами элементов. 
Обратите внимание, что диапазон определяется как [первый, последний), где последний ссылается на элемент, 
который находится после последнего элемента, который нужно проверить или изменить.

--------------------------------------------------------------------
предикат = функция которая возвращает bool, есть унарная и бинарная

--------------------------------------------------------------------
Алокатор = специализированный класс,
реализующий и инкапсулирующий малозначимые (с прикладной точки зрения) 
детали распределения и освобождения ресурсов компьютерной памяти.
--------------------------------------------------------------------
Функторы = класс, у которого перегружена операция ()
--------------------------------------------------------------------

контейнер = шаблон класса который вмещает в себя любые данные одного типа и предоставляет
операции для манипуляции этими данными

контейнеры:
последовательные (Sequence) = (vector, array, list, deque, forward_list)
расположены один за одним, не обязательно в памяти, но линейный поиск подходит

асоциативные (associative) = (set, map, multiset, multimap)
на основе бинарного дерева, ассоциация в том, что есть ключ и он ассоциируется со значением
O(log n)

неупорядоченные асоциативные (unordered associative) = (unordered_set, unordered_map, unordered_multiset, unordered_unordered)
на основе хеш-таблиц, ассоциация в том, что есть ключ и он ассоциируется со значением

Адапторы контейнеров (Adaptors) = (stack, queue, priority_queue)
Адапторы - потому что они ограничивают определенные контейнеры, заставляя их вести себя так,
как будто это другие структуры данных
берется какой-то последовательный контейнер и его функционал огнаричен


последовательные:
vector:
динамический массив
Insert: Вставка O(1) push_back. another O(n) (амортизированая скорость)
Access: Доступ до елементу О(1)
Erase: Удаление O(1) pop_back. another O(n) (амортизированая скорость)
Search: поиск О(n) линейный поиск
у вектора есть операция перегруженная [], у листа = нету если много поиска, то лучше вектор


list:
Insert: O(1) перепривязывание соседних адресов
Access: O(1) Доступ только по итератору(когда он есть). О(n) если нужно найти значение
Erase: O(1) перепривязывание соседних адресов
Search: O(n) линейный поиск


forward_list:
Insert: O(1) перепривязывание соседних адресов
Access: O(1) Доступ только по итератору(когда он есть). О(n) если нужно найти значение
Erase: O(1) перепривязывание соседних адресов
Search: O(n) линейный поиск
forward_list занимает меньше памяти и если мы не будем двигаться реверсивно(в обратном порядке)
по сравнение с листом

dequeue:
похожий на вектор, но лучший для перераспределения памяти, при перераспределении память фиксированая
если у вектора всегда выделается память с помощью капасити и увеливается затрата времени, потому что перемещение
и перераспределение требует это, то у дека всегда один размер переопределяется
минусы в том что память выделаеться не рядом, а произвольно где есть место
короче говоря проиходит перераспределение указателей, а не как у вектора перераспределение памяти
тоже есть операция перегруженная [] но работает дольше чем у вектора, потому что требуется
разыминование
Insert: Вставка O(1) push_back и push_front (амортизированая O(1) скорость)
Access: О(1) (независит от количества елементов, но у вектора быстрее)
Erase: Удаление O(1) pop_back and pop_front, О(n) . То есть амортизированная
Search: поиск О(n) линейный поиск 

arrray:
массив не может меняться, данные на стеке
Insert: -
Access: O(1)
Erase: -
Search: O(n) линейный поиск

--------------------------------------------------------------------
Адапторы контейнеров: берется какой-то последовательный контейнер и его функционал огнаричен

stack:
O notation в зависимости от внутреннего контейнера, Search (поиска нет)
под капотом = deque
Insert: только в конец 
Erase: только в конце

queue:
O notation в зависимости от внутреннего контейнера, Search (поиска нет)
под капотом = deque
Insert: только в конец 
Erase: только в начале

priority_queue:
под капотом = vector, но данные сохраняются как двоичная куча(binary heap)
O notation в зависимости от внутреннего контейнера, Search (поиска нет)
Insert: только в конец 
Erase: только в конец

--------------------------------------------------------------------
Асоциативные контейнеры

set = под капотом бинарное дерево. это контейнер, который автоматически сортирует 
добавляемые элементы в порядке возрастания. Но при добавлении одинаковых значений, 
set будет хранить только один его экземпляр.
По другому его еще называют множеством.
О(log n) = абсолютно всё, кроме доступа до елемента, оно O(1) Доступ только по итератору(когда он есть). 
О(n) если нужно найти значение

multiset = то контейнер, который также будет содержать элементы в отсортированном порядке при добавлении, 
но он хранит повторяющееся элементы, по сравнению с множеством set.
Часто его называют мультимножество.
О(log n) = абсолютно всё, кроме доступа до елемента, оно =  O(1) 
если Доступ только по итератору(когда он есть). 
О(n) если нужно найти значение

map = хранит в себе пару( значение + ключ)
построение этого контейнера(на бинарном дереве) на основе ключа, а значение подвязывается
под капотом бинарное дерево
только уникальные значения
есть перегруженный оператор []
и есть метод at()

multimap = хранит в себе пару( значение + ключ)
построение этого контейнера(на бинарном дереве) на основе ключа, а значение подвязывается
под капотом бинарное дерево
может и дублирующие значения
нету = перегруженный оператор []
нету = метод at()
--------------------------------------------------------------------
Неупорядоченные асоциативные контейнеры

unordered_set

unordered_multiset

unordered_map

unordered_multimap
--------------------------------------------------------------------
в С++ 20 есть контейнер - span =





вариативные шаблоны:
функция со сменным числом параметров
мета операций = ... Args = обьявления идентификатора для пакета параметра шаблонов, функций(список типов)



шаблонный класс pair  = пара




\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/

difference conteiners

\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/


std::list vs std::vector
вставка или удаление у std::vector = линейная сложность О(n)
вставка или удаление у std::list = Константная сложность О(1)
операция обращения по индексу = std::vector = константная сложность
операция обращения по индексу = std::list = линейная сложность
--------------------------------------------------------------------
отличия std::map от std::unordered_map
map на основе дерева (хранения ключа в сорт порядке) О(1)
unordered_map на основе хеш таблицы (хранения ключа в хаотичном порядке) О(log n)
--------------------------------------------------------------------
std::set от std::multiset

--------------------------------------------------------------------

