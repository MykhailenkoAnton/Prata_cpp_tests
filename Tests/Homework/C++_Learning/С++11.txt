что появилось в стандарте С++11:

auto

nullptr = ключевое слово, введенное в C++11 для описания нулевого указателя.

move семантика (контструктор переноса, операция присваивания с переносом)

range for (цикл по диапазону)

лямда-функции

<thread> многопоточность

constexpr

смарт поинтеры (make_unique, make_share и т.д.)

override и final = для виртуальных функций

строго-типизированный enum
Эти проблемы устранены в С++11 с введением новой категории перечислений, названных strongly-typed enums.
Они определяются ключевым словом enum class. Они больше не экспортируют свои перечисляемые значения в окружающую область 
видимости, больше не преобразуются неявно в целый тип и могут иметь определенный пользователем тип 
(эта опция так же добавлена и для «традиционных» перечислений").

non-member begin() и end()
Вы, вероятно, заметили, что в примерах ранее, я использовал функции begin() и end().
 Это новое дополнение к стандартной библиотеке. 
Они работают со всеми контейнерами STL и могут быть расширены для работы с любым типом.

static_assert и классы свойств
static_assert проверяет утверждение во время компиляции. Если утверждение — истина, то ничего не происходит.
Если — ложь, то компилятор выводит указанное сообщение об ошибке.


decltype(к примеру адресс лямбды(то есть имя лямбды)) = берет обьект и определяет его тип

constexpr   
вычисляются данные и функции на этапе компиляции

auto компилятор сам определяет тип
только при инициализации переменных



лямда функция: (это функтор) = анонимная функция с уникальным именем созданным компилятором
под капотом создается класс