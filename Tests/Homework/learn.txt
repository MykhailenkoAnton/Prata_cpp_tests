задачи:

многопоточность
set, map
паттерны проектирования
алокаторы
decltype
======================================================================

решить вопросы:

======================================================================

вопросы:

======================================================================
#include <iostream>
const int SIZE = 5;

// быстрая сортировка
void QuickSort(int arr[], int first, int last)
{
    int middle = arr[(first + last) / 2];
    int i = first;
    int j = last;
    do
    {
        while (arr[i] < middle)
        {
            i++;
        }
        while (arr[j] > middle)
        {
            j--;
        }
        if (i <= j)
        {
            std::swap(arr[i], arr[j]);
            i++;
            j--;
        }
    } while (i <= j);

    if (j > first)
    {
        QuickSort(arr, first, j);
    }
    if (i < last)
    {
        QuickSort(arr, i, last);
    }
    
}

//пузырьковая
int main(){
    
    int arr[SIZE] = {3, 1, 5, 2, 7};
    
    for(int i = 0; i < SIZE; i++)
    {
        for(int j = SIZE - 1; j > i; j--)
        {
            if(arr[j] < arr[j - 1])
            {
                int temp = arr[j];
                arr[j] = arr[j - 1];
                arr[j - 1] = temp;
            }
        }
        
    }
    
    for(int i = 0; i < SIZE; i++)
    {
        std::cout << arr[i] << ' ';
    }
    
    
    return 0;
}

//вставками
void InSort(int * arr, int size)
{
    for(int i = 1; i < size; i++)
    {
        int key = arr[i];
        int j;
        for(j = i - 1; j >= 0 && arr[j] > key; j--)
        {
            arr[j + 1] = arr[j];
        }
          arr[j + 1] = key;
    }
}

// бинарный поиск только после сортировки
bool biSearch(int * arr, int size, int n)
{
    int leftSide = 0;
    int rightSide = size - 1;
    
    while(leftSide <= rightSide)
    {
        int middle = (leftSide + rightSide) / 2;
        if(n == arr[middle])
            return true;
        else if(n > arr[middle])
            leftSide = middle + 1;
        else if(n < arr[middle])
            rightSide = middle - 1;
          
    }
    return false;
}

// линейный поиск
int findN(int * arr, int size, int key);
int main()
{
    int arr[10] = {4, 5, 2, 1, 3, 11, 3, 4, 5, 9};
    std::cout << "Enter a key: ";
    int key;
    std::cin >> key;
    
    int result = findN(arr, 10, key);
    
    if(result != -1)
    {
        std::cout << "Yes its #" << result << std::endl;
    }
    else
    {
        std::cout << "No!\n";
    }
    
    return 0;
}
int findN(int * arr, int size, int key)
{
    for (int i = 0; i < 10; i++)
    {
        if (key == arr[i])
        {
            return i;
        }
    }
    return -1;
}

======================================================================

Что такое this? это скрытый константный указатель, содержащий адрес объекта, который вызывает метод класса.
Ключевое слово this представляет указатель на текущий объект данного класса. 
Соответственно через this мы можем обращаться внутри класса к любым его членам.

======================================================================
Що таке абстрактний клас і навіщо він?
В об'єктно-орієнтованому програмуванні абстрактний клас – це базовий клас, 
від якого не можна створити екземпляру. 
На практиці абстрактні класи реалізують один з принципів ООП – поліморфізм.
В абстрактному класі можна описати (або не визначити) абстрактні методи та властивості.
Должен содержать как минимум одну чистую виртуальную функцию

======================================================================
передаете параметр по значению, 
внутри функции создается копия n, и n становится копия параметра, а не сам параметр.

Когда в функцию передаётся объект по ссылке, то передаётся фактически этот объект. 
Когда же мы передаём объект по значению, то в функцию передаётся его копия.

Единственное заметное отличие: указатель может быть нулевым, а ссылка нет - она всегда должна указывать
на какой-то объект (попытка создать ссылку из нулевого указателя вызывает неопределенное поведение).

Передача параметр через указатель передает адресс обьекта, и что бы изменить содержимое мы долны его разыминовать

======================================================================

Що таке memory leak?
это неконтролируемое уменьшение свободной оперативной или виртуальной памяти компьютера. 
Причиной утечек становятся ошибки в программном коде.


======================================================================

enum от enum class
enum конвертируется в int без предупреждения, т.е. он фактически является int-типом.
enum class будет отдельным типом.
т.е. enum class colors {red, green} нельзя случайно превратить в enum class dangerLevel {red, yellow, green},
только принудительно скастить
спасает от ошибок, поскольку программисту придется подумать,
прежде чем скастовать цвет светофора в уровень опасности
спасает от неявного преобразования

======================================================================

Виртуальная функция в языке С++ — это особый тип функции, которая, при её вызове, 
выполняет «наиболее» дочерний метод, который существует между родительским и дочерними классами. 
Это свойство еще известно, как полиморфизм. Дочерний метод вызывается тогда, когда совпадает сигнатура
(имя, типы параметров и является ли метод константным) и тип возврата дочернего метода с сигнатурой 
и типом возврата метода родительского класса.
Такие методы называются переопределениями (или «переопределенными методами»).

======================================================================
smart pointer = класс, который имитирует указатель на определенный обьект
почему smart? при уничтожении указателя уничтожается обьект на который он указывает
unique_ptr<A> ptr; только один указатель на обьект
share_ptr<A> ptr; несколько указателей на обьект
weak_ptr<A> ptr; проверяет живой ли обьект(с помощью share_ptr)
======================================================================

Зачем нужен виртуальный деструктоор
Деструкторы предназначены для очистки памяти и ресурсов. 
Если деструктор Foo не является виртуальным, то при уничтожении объект Bar все равно будет вызван 
деструктор базового класса Foo. Поэтому деструкторы объявляют виртуальными 
— это гарантирует, что будет вызван деструктор для производного класса.

======================================================================
explicit

Если спросить C++-программиста о значении ключевого слова explicit, 
большинство ответит, что это ключевое слово ставится перед объявлением конструктора с 
одним параметром (или с большим числом параметров, но когда все параметры, начиная со второго, 
имеют значения по умолчанию) и предотвращает неявное преобразование типов при инициализации.

Помимо этого, начиная с C++11 ключевое слово explicit может 
также применяться к операторам преобразования типа, также запрещая их неявный вызов

В заключение хочется порекомендовать использовать универсальную инициализацию 
в любом новом коде на C++, а также явно объявлять конструкторы explicit всегда, кроме случаев, 
когда неявное преобразование семантически оправдано.


======================================================================

виды памяти:

Статическая — выделение памяти до начала исполнения программы. 
Такая память доступна на протяжении всего времени выполнения программы.
Во многих языках для размещения объекта
в статической памяти достаточно задекларировать его в глобальной области видимости.

Автоматическая, также известный как «размещение на стеке», — самый основной, 
автоматически выделяет аргументы и локальные переменные функции, 
а также прочую метаинформацию при вызове функции и освобождает память при выходе из неё.

Динамическая — выделение памяти из ОС по требованию приложения.
Автоматическая и статическая память выделяются единоразово перед запуском программы. 
При их нехватке, либо если модель LIFO не совсем подходит, используется динамическая память.


======================================================================

исключения:(exception)
определенный обьект(любой)(любые данные) который содержит в себе информацию об ошибке (любой ошибке)


======================================================================

лямда функция: (это функтор) = анонимная функция с уникальным именем созданным компилятором
под капотом создается класс


======================================================================

функтор:
класс у которого перегруженный вызов функции

======================================================================
auto компилятор сам определяет тип
только при инициализации переменных
======================================================================

static_cast<Type> = безопасное приведения типа
dynamic_cast<Type> = для указателей на классы
const_cast<Type> снимает или добавляет константость
reinterpted_cast<Type> для небезобасных приведений типов

mutable делает константную переменную меняемой
======================================================================

шаблонный класс pair  = пара

======================================================================

typeid
======================================================================

constexpr   
вычисляются данные и функции на этапе компиляции
======================================================================

вариативные шаблоны:
функция со сменным числом параметров
мета операций = ... Args = обьявления идентификатора для пакета параметра шаблонов, функций(список типов)

======================================================================
sizeof - размер типа в байтах
sizeof ... количество параметров в функции
======================================================================
О(нотация) - математическое обозначение сложности(скорости) алгоритма

Константная сложность О(1) (нахождение определенного елемента в массиве(контейнере))
пример: return arr[i]; то же самое что и return *(arr + i);
от времени не зависит, потому что добавляем к адресу индекс, разыминовываем и возващаем


Алгоритмическая О(log n)
бинарный поиск к примеру в бинарном дереве


Линейная сложность O(n)
время прямопропорционально зависит от количества елементов в массиве и т.д.
пример: std::cout << arr[i] , прохождение по всем елеменам массива пока i != arr[end]
так же с математическими операциями для всех елементов в массиве
линейный поиск == O(n/2) (уточнение)


О(n * long n)
Quick Sort

Квадратная сложность О(n ^ 2)
пример: Двухвымерный массив с одинаковым размером i and j, иначе скорость будет О(x * y)
сортировка выборочная, вставками, пузырьковая(самый лучший что может быть = O(n))

Кубическая сложность О(n ^ 3)
пример: цикл в цикле в цикле с одинаковым размером i and j, иначе скорость будет О(a * b * c)
======================================================================
ADT Абстрактные типы данных: 
Односвязный список, Двухсвязный список, Стек, Очеред, Бинарное дерево

Односвязный список:





======================================================================
STL : контейнеры, алгоритмы, итераторы, предикаты (функторы, алокаторы)

Итераторы = 
Библиотека итераторов предоставляет определения итераторов для пяти (до C++17)шести 
(начиная с C++17) видов, а также свойств итераторов, адаптеров и служебных функций.
Категории итераторов
Существует пять (до C++17)шесть (начиная с C++17) видов итераторов: 
LegacyInputIterator, LegacyOutputIterator, LegacyForwardIterator,
LegacyBidirectionalIterator, LegacyRandomAccessIterator и LegacyContiguousIterator (начиная с C++17).
Вместо того, чтобы определяться конкретными типами, каждая категория итераторов определяется операциями, 
которые могут быть выполнены с нею. Это определение означает, что любой тип, поддерживающий 
необходимые операции, может использоваться в качестве итератора – например, указатель поддерживает
все операции, требуемые для LegacyRandomAccessIterator, поэтому указатель можно использовать где угодно,
где ожидается LegacyRandomAccessIterator.
Все категории итераторов (кроме LegacyOutputIterator) могут быть организованы в иерархию, 
где более мощные категории итераторов (например, LegacyRandomAccessIterator) поддерживают операции менее
мощных категорий (например, LegacyInputIterator). Если итератор попадает в одну из этих категорий и также 
соответствует требованиям LegacyOutputIterator, то он называется изменяемым итератором и поддерживает ввод 
и вывод.
Неизменяемые итераторы называются константными итераторами.
--------------------------------------------------------------------
Алгоритм (в контексте STL) это функции которая работает с контейнером через итератор
потому что итераторы предоставляют абстракцию по отношению ко всем контейнерам 
алгоритмы = Библиотека алгоритмов определяет функции для различных целей 
(например, поиск, сортировка, подсчёт, манипулирование), которые работают с диапазонами элементов. 
Обратите внимание, что диапазон определяется как [первый, последний), где последний ссылается на элемент, 
который находится после последнего элемента, который нужно проверить или изменить.

--------------------------------------------------------------------
предикат = функция которая возвращает bool, есть унарная и бинарная

--------------------------------------------------------------------
Алокатор = специализированный класс,
реализующий и инкапсулирующий малозначимые (с прикладной точки зрения) 
детали распределения и освобождения ресурсов компьютерной памяти.
--------------------------------------------------------------------
Функторы = класс, у которого перегружена операция ()
--------------------------------------------------------------------

контейнер = шаблон класса который вмещает в себя любые данные одного типа и предоставляет
операции для манипуляции этими данными

контейнеры:
последовательные (Sequence) = (vector, array, list, deque, forward_list)
расположены один за одним, не обязательно в памяти, но линейный поиск подходит

асоциативные (associative) = (set, map, multiset, multimap)
на основе бинарного дерева, ассоциация в том, что есть ключ и он ассоциируется со значением
O(log n)

неупорядоченные асоциативные (unordered associative) = (unordered_set, unordered_map, unordered_multiset, unordered_unordered)
на основе хеш-таблиц, ассоциация в том, что есть ключ и он ассоциируется со значением

Адапторы контейнеров (Adaptors) = (stack, queue, priority_queue)
Адапторы - потому что они ограничивают определенные контейнеры, заставляя их вести себя так,
как будто это другие структуры данных
берется какой-то последовательный контейнер и его функционал огнаричен


последовательные:
vector:
динамический массив
Insert: Вставка O(1) push_back. another O(n) (амортизированая скорость)
Access: Доступ до елементу О(1)
Erase: Удаление O(1) pop_back. another O(n) (амортизированая скорость)
Search: поиск О(n) линейный поиск
у вектора есть операция перегруженная [], у листа = нету если много поиска, то лучше вектор


list:
Insert: O(1) перепривязывание соседних адресов
Access: O(1) Доступ только по итератору(когда он есть). О(n) если нужно найти значение
Erase: O(1) перепривязывание соседних адресов
Search: O(n) линейный поиск


forward_list:
Insert: O(1) перепривязывание соседних адресов
Access: O(1) Доступ только по итератору(когда он есть). О(n) если нужно найти значение
Erase: O(1) перепривязывание соседних адресов
Search: O(n) линейный поиск
forward_list занимает меньше памяти и если мы не будем двигаться реверсивно(в обратном порядке)
по сравнение с листом

dequeue:
похожий на вектор, но лучший для перераспределения памяти, при перераспределении память фиксированая
если у вектора всегда выделается память с помощью капасити и увеливается затрата времени, потому что перемещение
и перераспределение требует это, то у дека всегда один размер переопределяется
минусы в том что память выделаеться не рядом, а произвольно где есть место
короче говоря проиходит перераспределение указателей, а не как у вектора перераспределение памяти
тоже есть операция перегруженная [] но работает дольше чем у вектора, потому что требуется
разыминование
Insert: Вставка O(1) push_back и push_front (амортизированая O(1) скорость)
Access: О(1) (независит от количества елементов, но у вектора быстрее)
Erase: Удаление O(1) pop_back and pop_front, О(n) . То есть амортизированная
Search: поиск О(n) линейный поиск 

arrray:
массив не может меняться, данные на стеке
Insert: -
Access: O(1)
Erase: -
Search: O(n) линейный поиск




Адапторы контейнеров: берется какой-то последовательный контейнер и его функционал огнаричен

stack:
O notation в зависимости от внутреннего контейнера, Search (поиска нет)
под капотом = deque
Insert: только в конец 
Erase: только в конце

queue:
O notation в зависимости от внутреннего контейнера, Search (поиска нет)
под капотом = deque
Insert: только в конец 
Erase: только в начале

priority_queue:
под капотом = vector, но данные сохраняются как двоичная куча(binary heap)
O notation в зависимости от внутреннего контейнера, Search (поиска нет)
Insert: только в конец 
Erase: только в конец




в С++ 20 есть контейнер - span = ?






======================================================================

что появилось в стандарте С++11:


auto

nullptr = ключевое слово, введенное в C++11 для описания нулевого указателя.

move семантика (контструктор переноса, операция присваивания с переносом)

range for (цикл по диапазону)

лямда-функции

<thread> многопоточность

constexpr

смарт поинтеры (make_unique, make_share и т.д.)

override и final = для виртуальных функций

строго-типизированный enum
Эти проблемы устранены в С++11 с введением новой категории перечислений, названных strongly-typed enums.
Они определяются ключевым словом enum class. Они больше не экспортируют свои перечисляемые значения в окружающую область 
видимости, больше не преобразуются неявно в целый тип и могут иметь определенный пользователем тип 
(эта опция так же добавлена и для «традиционных» перечислений").

non-member begin() и end()
Вы, вероятно, заметили, что в примерах ранее, я использовал функции begin() и end().
 Это новое дополнение к стандартной библиотеке. 
Они работают со всеми контейнерами STL и могут быть расширены для работы с любым типом.

static_assert и классы свойств
static_assert проверяет утверждение во время компиляции. Если утверждение — истина, то ничего не происходит.
Если — ложь, то компилятор выводит указанное сообщение об ошибке.

======================================================================
этапы сборки:
1) ПРЕПРОЦЕССИНГ
Препроцессор — это макро процессор, который преобразовывает вашу программу для дальнейшего компилирования. 
На данной стадии происходит происходит работа с препроцессорными директивами. 
Например, препроцессор добавляет хэдеры в код (#include), убирает комментирования, 
заменяет макросы (#define) их значениями, выбирает нужные куски кода в соответствии с условиями 
#if, #ifdef и #ifndef.


2) КОМПИЛЯЦИЯ
На данном шаге g++ выполняет свою главную задачу — компилирует, 
то есть преобразует полученный на прошлом шаге код без директив в ассемблерный код. 
Это промежуточный шаг между высокоуровневым языком и машинным (бинарным) кодом.

3) АССЕМБЛИРОВАНИЕ
Так как x86 процессоры исполняют команды на бинарном коде, 
необходимо перевести ассемблерный код в машинный с помощью ассемблера.
Ассемблер преобразовывает ассемблерный код в машинный код, сохраняя его в объектном файле.
Объектный файл — это созданный ассемблером промежуточный файл, хранящий кусок машинного кода. 
Этот кусок машинного кода, который еще не был связан 
вместе с другими кусками машинного кода в конечную выполняемую программу, называется объектным кодом.
Далее возможно сохранение данного объектного кода в статические библиотеки для того, 
чтобы не компилировать данный код снова.

4) КОМПОНОВКА (ЛИНКОВКА)
Компоновщик (линкер) связывает все объектные файлы и статические библиотеки в единый исполняемый файл, 
который мы и сможем запустить в дальнейшем.
Для того, чтобы понять как происходит связка, следует рассказать о таблице символов.

======================================================================

что такое ссылка?
это тип переменной в языке C++, который работает как псевдоним другого объекта или значения.

что такое указатель?
это переменная(тип переменной), которая хранит в себе адресс! (обьекта, переменой и т.д.)


Отличия указателя от ссылки:

Нельзя объявить массив ссылок.
У ссылки нет адреса.
Существует арифметика указателей, но нет арифметики ссылок.
Указатель может иметь «невалидное» значение с которым его можно сравнить перед использованием.
Ссылка не обладает квалификатором const

Нельзя создать массив ссылок
Ссылка должна на что-то ссылаться обьязательно
нельзя ссылке присвоить nullptr
не имеет смысла делать константную ссылку
int& const r = v; такого нет в природе
const int& r = v; ссылается на константные данные
разыминовать ссылку нельзя
сслылается только на один обьект


======================================================================

Что такое ООП? 
программирование, (Методология программирования)
которое ориентируется на обьекты. Строится на обьектах и классах. Три основных свойства ООП описаны нижею.

есть процедурное програмирование, как язык С, ориентируется на данные и функции обрабатующие данные.
А есть обобщенное програмирование, ориентируется на шаблоны функций и классов (определенный аглоритм для любых типов данных)


Инкапсуляция = сокрытия данных, запрещающая пользователю имзенять данные или код
(или «сокрытие информации») — это процесс скрытого хранения деталей реализации объекта. 
Пользователи обращаются к объекту через открытый интерфейс.
В языке C++ инкапсуляция реализована через спецификаторы доступа.
концепция ООП которая позволяет обьеденять данные и методы их обработки в одну сутность = класс или структура
и защищает их от внешнего вмешательство посредством модификаторов доступа

Полиморфизм = в большей мере относится к виртуальным функциям
Свойство программного кода изменять свое поведение в зависимости от ситуации, возникающей при выполнении программы.
концепция в ООП которая позволяет получать разную реализацию(кода) за одним интерфейсом
ad hoc (overload foo())
параметризованый (шаблоны функций)
полиморфизм подтипов(виртуальные функции)

Наследование = создание одного(производного) класса и его интерфейса, посредством другого(базового)
(механизм, который позволяет наследовать функциональность одного класса или базового класса (base class)
в другом - производном классе (derived class))
концепция ООП которая позволяет создавать новые классы на основании существующих

Абстракция = это использование только тех характеристик объекта, которые с достаточной точностью представляют его в данной системе.
Основная идея состоит в том, чтобы представить объект минимальным набором полей и методов 
и при этом с достаточной точностью для решаемой задачи.
концепция в ООП которая позволяет отсоединять общие признаки разных классов и обьединять их в общем классе


======================================================================

статический метод класса не имеет указателя this

======================================================================

итератор = Итератор — интерфейс, предоставляющий доступ к элементам коллекции(контейнера) и навигацию по ним.
Класс(шаблон класса), который имитирует указатель на елементы контейнера
были придуманны что бы мы могли писать функции, которые работают со всеми контейнерами одинаково

======================================================================

что такое класс?
класс = тип(тип данных) определенный пользователем

======================================================================

типы с++

логический тип данных:
bool (0 || 1) 1 byte

-------------------

символьеные типы данных:
char (signed char) (0...255) 1 byte

unsigned char (-128 + 127) 1 byte

wchar_t(2 bytes (0...65535), (0 до 4 294 967 295 (для 4 байт)))

char16_t (2 bytes (0...65535))

char32_t(0 до 4 294 967 295 (для 4 байт))

-------------------

целочисленные типы данных:
short (от –32768 до 32767) 2 bytes

unsigned short (от 0 до 65535) 2 bytes

int (В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита))
(от –32768 до 32767 (при 2 байтах) или от −2 147 483 648 до 2 147 483 647 (при 4 байтах))

unsigned int || unsigned (от 0 до 65535 (для 2 байт), либо от 0 до 4 294 967 295 (для 4 байт))

long (−2 147 483 648 до 2 147 483 647. Занимает в памяти 4 байта)

unsigned long (от 0 до 4 294 967 295. Занимает в памяти 4 байта)

long long (от −9 223 372 036 854 775 808 до +9 223 372 036 854 775 807. Занимает в памяти, как правило, 8 байт)

unsigned long long (0 до 18 446 744 073 709 551 615. Занимает в памяти, как правило, 8 байт)

-------------------

типы с плавающей точкой:

float (+/- 3.4E-38 до 3.4E+38. В памяти занимает 4 байта)

double (+/- 1.7E-308 до 1.7E+308. В памяти занимает 8 байт)

long double (В зависимости от размера занимаемой памяти может отличаться диапазон допустимых значений, не менее 8 байт)

-------------------

void: тип без значения

======================================================================