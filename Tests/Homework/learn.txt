задачи:

STL и итераторы подробнее
что появилось в стандарте С++11
======================================================================

решить вопросы:

======================================================================

вопросы:
скачивать проект по ssh или по ссылке существующий?
что бы доступ к одному проекту было с двух или больше моих компов?

======================================================================
#include <iostream>
const int SIZE = 5;

//пузырьковая
int main(){
    
    int arr[SIZE] = {3, 1, 5, 2, 7};
    
    for(int i = 0; i < SIZE; i++)
    {
        for(int j = SIZE - 1; j > i; j--)
        {
            if(arr[j] < arr[j - 1])
            {
                int temp = arr[j];
                arr[j] = arr[j - 1];
                arr[j - 1] = temp;
            }
        }
        
    }
    
    for(int i = 0; i < SIZE; i++)
    {
        std::cout << arr[i] << ' ';
    }
    
    
    return 0;
}

//вставками
void InSort(int * arr, int size)
{
    for(int i = 1; i < size; i++)
    {
        int key = arr[i];
        int j;
        for(j = i - 1; j >= 0 && arr[j] > key; j--)
        {
            arr[j + 1] = arr[j];
        }
          arr[j + 1] = key;
    }
}

// бинарный поиск только после сортировки
bool biSearch(int * arr, int size, int n)
{
    int leftSide = 0;
    int rightSide = size - 1;
    
    while(leftSide <= rightSide)
    {
        int middle = (leftSide + rightSide) / 2;
        if(n == arr[middle])
            return true;
        else if(n > arr[middle])
            leftSide = middle + 1;
        else if(n < arr[middle])
            rightSide = middle - 1;
          
    }
    return false;
}

// линейный поиск
int findN(int * arr, int size, int key);
int main()
{
    int arr[10] = {4, 5, 2, 1, 3, 11, 3, 4, 5, 9};
    std::cout << "Enter a key: ";
    int key;
    std::cin >> key;
    
    int result = findN(arr, 10, key);
    
    if(result != -1)
    {
        std::cout << "Yes its #" << result << std::endl;
    }
    else
    {
        std::cout << "No!\n";
    }
    
    return 0;
}
int findN(int * arr, int size, int key)
{
    for (int i = 0; i < 10; i++)
    {
        if (key == arr[i])
        {
            return i;
        }
    }
    return -1;
}

======================================================================

Что такое this? это скрытый константный указатель, содержащий адрес объекта, который вызывает метод класса.
Ключевое слово this представляет указатель на текущий объект данного класса. 
Соответственно через this мы можем обращаться внутри класса к любым его членам.

======================================================================
Що таке абстрактний клас і навіщо він?
В об'єктно-орієнтованому програмуванні абстрактний клас – це базовий клас, 
від якого не можна створити екземпляру. 
На практиці абстрактні класи реалізують один з принципів ООП – поліморфізм.
В абстрактному класі можна описати (або не визначити) абстрактні методи та властивості.
Должен содержать как минимум одну чистую виртуальную функцию

======================================================================
передаете параметр по значению, 
внутри функции создается копия n, и n становится копия параметра, а не сам параметр.

Когда в функцию передаётся объект по ссылке, то передаётся фактически этот объект. 
Когда же мы передаём объект по значению, то в функцию передаётся его копия.

Единственное заметное отличие: указатель может быть нулевым, а ссылка нет - она всегда должна указывать
на какой-то объект (попытка создать ссылку из нулевого указателя вызывает неопределенное поведение).

Передача параметр через указатель передает адресс обьекта, и что бы изменить содержимое мы долны его разыминовать

======================================================================

Що таке memory leak?
это неконтролируемое уменьшение свободной оперативной или виртуальной памяти компьютера. 
Причиной утечек становятся ошибки в программном коде.


======================================================================

enum от enum class
enum конвертируется в int без предупреждения, т.е. он фактически является int-типом.
enum class будет отдельным типом.
т.е. enum class colors {red, green} нельзя случайно превратить в enum class dangerLevel {red, yellow, green},
только принудительно скастить
спасает от ошибок, поскольку программисту придется подумать,
прежде чем скастовать цвет светофора в уровень опасности
спасает от неявного преобразования

======================================================================

Виртуальная функция в языке С++ — это особый тип функции, которая, при её вызове, 
выполняет «наиболее» дочерний метод, который существует между родительским и дочерними классами. 
Это свойство еще известно, как полиморфизм. Дочерний метод вызывается тогда, когда совпадает сигнатура
(имя, типы параметров и является ли метод константным) и тип возврата дочернего метода с сигнатурой 
и типом возврата метода родительского класса.
Такие методы называются переопределениями (или «переопределенными методами»).

======================================================================
smart pointer = класс, который имитирует указатель на определенный обьект
почему smart? при уничтожении указателя уничтожается обьект на который он указывает
unique_ptr<A> ptr; только один указатель на обьект
share_ptr<A> ptr; несколько указателей на обьект
weak_ptr<A> ptr; проверяет живой ли обьект(с помощью share_ptr)
======================================================================

Зачем нужен виртуальный деструктоор
Деструкторы предназначены для очистки памяти и ресурсов. 
Если деструктор Foo не является виртуальным, то при уничтожении объект Bar все равно будет вызван 
деструктор базового класса Foo. Поэтому деструкторы объявляют виртуальными 
— это гарантирует, что будет вызван деструктор для производного класса.

======================================================================
explicit

Если спросить C++-программиста о значении ключевого слова explicit, 
большинство ответит, что это ключевое слово ставится перед объявлением конструктора с 
одним параметром (или с большим числом параметров, но когда все параметры, начиная со второго, 
имеют значения по умолчанию) и предотвращает неявное преобразование типов при инициализации.

Помимо этого, начиная с C++11 ключевое слово explicit может 
также применяться к операторам преобразования типа, также запрещая их неявный вызов

В заключение хочется порекомендовать использовать универсальную инициализацию 
в любом новом коде на C++, а также явно объявлять конструкторы explicit всегда, кроме случаев, 
когда неявное преобразование семантически оправдано.


======================================================================

виды памяти:

Статическая — выделение памяти до начала исполнения программы. 
Такая память доступна на протяжении всего времени выполнения программы.
Во многих языках для размещения объекта
в статической памяти достаточно задекларировать его в глобальной области видимости.

Автоматическая, также известный как «размещение на стеке», — самый основной, 
автоматически выделяет аргументы и локальные переменные функции, 
а также прочую метаинформацию при вызове функции и освобождает память при выходе из неё.

Динамическая — выделение памяти из ОС по требованию приложения.
Автоматическая и статическая память выделяются единоразово перед запуском программы. 
При их нехватке, либо если модель LIFO не совсем подходит, используется динамическая память.


======================================================================

исключения:(exception)
определенный обьект(любой)(любые данные) который содержит в себе информацию об ошибке (любой ошибке)


======================================================================

лямда функция: (это функтор) = анонимная функция с уникальным именем созданным компилятором
под капотом создается класс


======================================================================

функтор:
класс у которого перегруженный вызов функции

======================================================================
auto компилятор сам определяет тип
только при инициализации переменных
======================================================================

static_cast<Type> = безопасное приведения типа
dynamic_cast<Type> = для указателей на классы
const_cast<Type> снимает или добавляет константость
reinterpted_cast<Type> для небезобасных приведений типов

mutable делает константную переменную меняемой
======================================================================

шаблонный класс pair  = пара

======================================================================

typeid
======================================================================

constexpr   
вычисляются данные и функции на этапе компиляции
======================================================================

вариативные шаблоны:
функция со сменным числом параметров
мета операций = ... Args = обьявления идентификатора для пакета параметра шаблонов, функций(список типов)

======================================================================
sizeof - размер типа в байтах
sizeof ... количество параметров в функции
======================================================================
О(нотация) - математическое обозначение сложности(скорости) алгоритма

Константная сложность О(1) (нахождение определенного елемента в массиве(контейнере))
пример: return arr[i]; то же самое что и return *(arr + i);
от времени не зависит, потому что добавляем к адресу индекс, разыминовываем и возващаем


Алгоритмическая О(log n)
бинарный поиск к примеру в бинарном дереве


Линейная сложность O(n)
время прямопропорционально зависит от количества елементов в массиве и т.д.
пример: std::cout << arr[i] , прохождение по всем елеменам массива пока i != arr[end]
так же с математическими операциями для всех елементов в массиве
линейный поиск == O(n/2) (уточнение)


О(n * long n)
Quick Sort

Квадратная сложность О(n ^ 2)
пример: Двухвымерный массив с одинаковым размером i and j, иначе скорость будет О(x * y)
сортировка выборочная, вставками, пузырьковая(самый лучший что может быть = O(n))

Кубическая сложность О(n ^ 3)
пример: цикл в цикле в цикле с одинаковым размером i and j, иначе скорость будет О(a * b * c)



======================================================================
======================================================================


этапы сборки:
1) ПРЕПРОЦЕССИНГ
Препроцессор — это макро процессор, который преобразовывает вашу программу для дальнейшего компилирования. 
На данной стадии происходит происходит работа с препроцессорными директивами. 
Например, препроцессор добавляет хэдеры в код (#include), убирает комментирования, 
заменяет макросы (#define) их значениями, выбирает нужные куски кода в соответствии с условиями 
#if, #ifdef и #ifndef.


2) КОМПИЛЯЦИЯ
На данном шаге g++ выполняет свою главную задачу — компилирует, 
то есть преобразует полученный на прошлом шаге код без директив в ассемблерный код. 
Это промежуточный шаг между высокоуровневым языком и машинным (бинарным) кодом.

3) АССЕМБЛИРОВАНИЕ
Так как x86 процессоры исполняют команды на бинарном коде, 
необходимо перевести ассемблерный код в машинный с помощью ассемблера.
Ассемблер преобразовывает ассемблерный код в машинный код, сохраняя его в объектном файле.
Объектный файл — это созданный ассемблером промежуточный файл, хранящий кусок машинного кода. 
Этот кусок машинного кода, который еще не был связан 
вместе с другими кусками машинного кода в конечную выполняемую программу, называется объектным кодом.
Далее возможно сохранение данного объектного кода в статические библиотеки для того, 
чтобы не компилировать данный код снова.

4) КОМПОНОВКА (ЛИНКОВКА)
Компоновщик (линкер) связывает все объектные файлы и статические библиотеки в единый исполняемый файл, 
который мы и сможем запустить в дальнейшем.
Для того, чтобы понять как происходит связка, следует рассказать о таблице символов.

======================================================================

что такое ссылка?
это тип переменной в языке C++, который работает как псевдоним другого объекта или значения.

что такое указатель?
это переменная(тип переменной), которая хранит в себе адресс! (обьекта, переменой и т.д.)


Отличия указателя от ссылки:

Нельзя объявить массив ссылок.
У ссылки нет адреса.
Существует арифметика указателей, но нет арифметики ссылок.
Указатель может иметь «невалидное» значение с которым его можно сравнить перед использованием.
Ссылка не обладает квалификатором const

Нельзя создать массив ссылок
Ссылка должна на что-то ссылаться обьязательно
нельзя ссылке присвоить nullptr
не имеет смысла делать константную ссылку
int& const r = v; такого нет в природе
const int& r = v; ссылается на константные данные
разыминовать ссылку нельзя
сслылается только на один обьект


======================================================================

Что такое ООП? 
программирование, (Методология программирования)
которое ориентируется на обьекты. Строится на обьектах и классах. Три основных свойства ООП описаны нижею.

есть процедурное програмирование, как язык С, ориентируется на данные и функции обрабатующие данные.
А есть обобщенное програмирование, ориентируется на шаблоны функций и классов (определенный аглоритм для любых типов данных)


Инкапсуляция = сокрытия данных, запрещающая пользователю имзенять данные или код
(или «сокрытие информации») — это процесс скрытого хранения деталей реализации объекта. 
Пользователи обращаются к объекту через открытый интерфейс.
В языке C++ инкапсуляция реализована через спецификаторы доступа.
концепция ООП которая позволяет обьеденять данные и методы их обработки в одну сутность = класс или структура
и защищает их от внешнего вмешательство посредством модификаторов доступа

Полиморфизм = в большей мере относится к виртуальным функциям
Свойство программного кода изменять свое поведение в зависимости от ситуации, возникающей при выполнении программы.
концепция в ООП которая позволяет получать разную реализацию(кода) за одним интерфейсом
ad hoc (overload foo())
параметризованый (шаблоны функций)
полиморфизм подтипов(виртуальные функции)

Наследование = создание одного(производного) класса и его интерфейса, посредством другого(базового)
(механизм, который позволяет наследовать функциональность одного класса или базового класса (base class)
в другом - производном классе (derived class))
концепция ООП которая позволяет создавать новые классы на основании существующих

Абстракция = это использование только тех характеристик объекта, которые с достаточной точностью представляют его в данной системе.
Основная идея состоит в том, чтобы представить объект минимальным набором полей и методов 
и при этом с достаточной точностью для решаемой задачи.
концепция в ООП которая позволяет отсоединять общие признаки разных классов и обьединять их в общем классе


======================================================================

статический метод класса не имеет указателя this

======================================================================

итератор = Итератор — интерфейс, предоставляющий доступ к элементам коллекции(контейнера) и навигацию по ним.
Класс(шаблон класса), который имитирует указатель на елементы контейнера

======================================================================

что такое класс?
класс = тип(тип данных) определенный пользователем

======================================================================

типы с++

логический тип данных:
bool (0 || 1) 1 byte

-------------------

символьеные типы данных:
char (signed char) (0...255) 1 byte

unsigned char (-128 + 127) 1 byte

wchar_t(2 bytes (0...65535), (0 до 4 294 967 295 (для 4 байт)))

char16_t (2 bytes (0...65535))

char32_t(0 до 4 294 967 295 (для 4 байт))

-------------------

целочисленные типы данных:
short (от –32768 до 32767) 2 bytes

unsigned short (от 0 до 65535) 2 bytes

int (В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита))
(от –32768 до 32767 (при 2 байтах) или от −2 147 483 648 до 2 147 483 647 (при 4 байтах))

unsigned int || unsigned (от 0 до 65535 (для 2 байт), либо от 0 до 4 294 967 295 (для 4 байт))

long (−2 147 483 648 до 2 147 483 647. Занимает в памяти 4 байта)

unsigned long (от 0 до 4 294 967 295. Занимает в памяти 4 байта)

long long (от −9 223 372 036 854 775 808 до +9 223 372 036 854 775 807. Занимает в памяти, как правило, 8 байт)

unsigned long long (0 до 18 446 744 073 709 551 615. Занимает в памяти, как правило, 8 байт)

-------------------

типы с плавающей точкой:

float (+/- 3.4E-38 до 3.4E+38. В памяти занимает 4 байта)

double (+/- 1.7E-308 до 1.7E+308. В памяти занимает 8 байт)

long double (В зависимости от размера занимаемой памяти может отличаться диапазон допустимых значений, не менее 8 байт)

-------------------

void: тип без значения

======================================================================