Що вам відомо про багатопотоковість?
/
когда ОС запускает процесс, процесс должен иметь как минимум один поток.
но можно создавать еще потоки, в зависимости от вашей физичкной апаратуры естественно
к примеру если у вас есть hyper threading(это два логических ядра на одном физическом)
можно создать два потока и ими управлять, но все же это не так кпдшно как если у вас есть
4 физ ядра и вы можете создавать 4 разных потока
Вы можете перенаправить на другой поток определенные сложные вычесление, что бы ваша программа в одном
потоке не ждала пока все необходимое должно вычислиться. иначе говоря распаралелить прогграму так, что бы
определенные вычесление занимали минимум времени
/
многопоточность - свойство кода программы выполняться параллельно(одновременно) на нескольких 
ядрах процессора(путем назначения каждому ядру потока выполнения(куска кода, который он должен обработать)) 
или выполняться псевдопараллельно на одном ядре(каждый поток получает в свое распоряжение некоторое время, 
за которое он успевает исполнить часть своего кода на процессоре). Распределением потоков по ядрам обычно 
занимается диспетчер, но при желании в коде программы можно явно привязать поток к какому-либо ядру.
----------------------------------------------------------------------------------------------------------
Що спільного і відмінного в процесах і потоках?
/
Процессы и потоки связаны друг с другом, но при этом имеют существенные различия.
/
Процесс — экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы 
(например, процессорное время и память). Каждый процесс выполняется в отдельном адресном пространстве: 
один процесс не может получить доступ к переменным и структурам данных другого. Если процесс хочет получить 
доступ к чужим ресурсам, необходимо использовать межпроцессное взаимодействие. Это могут быть конвейеры,
файлы, каналы связи между компьютерами и многое другое.
/
Поток использует то же самое пространства стека, что и процесс, а множество потоков совместно используют 
данные своих состояний. Как правило, каждый поток может работать (читать и писать) с одной и той же областью 
памяти, в отличие от процессов, которые не могут просто так получить доступ к памяти другого процесса. У 
каждого потока есть собственные регистры и собственный стек, но другие потоки могут их использовать.
/
Поток — определенный способ выполнения процесса. Когда один поток изменяет ресурс процесса, это изменение 
сразу же становится видно другим потокам этого процесса.
----------------------------------------------------------------------------------------------------------
Як синхронізувати передачі інформації між потоками?
/
с помощью mutex и semaphore
mutex имеет методы lock and unlock
lock закрывает часть для потока от других потоков, пока часть эта не будет выполнена до метода unlock
другие потоки не имею право туда зайти.
----------------------------------------------------------------------------------------------------------
Яка різниця між м’ютексом і семафором?
/
Семафор - це механізм сигналізації, оскільки операція wait () і signal (), 
що виконується на змінній семафора, вказує, чи процес отримує ресурс або звільняє ресурс. 
З іншого боку, мьютекс є механізмом блокування, оскільки для отримання ресурсу процес необхідно 
заблокувати об'єкт мьютекс і під час випуску процесу ресурсу необхідно розблокувати мьютекс-об'єкт.
/
Семафор, як правило, є цілою змінною, тоді як mutex є об'єктом .
/
Семафор дозволяє декільком потокам програм отримати доступ до кінцевого екземпляра ресурсів . 
З іншого боку, Mutex дозволяє декільком потокам програм отримати доступ до одного загального ресурсу, 
але за один раз.
/
Значення змінної Semaphore може бути змінено будь-яким процесом, який отримує або видаляє ресурс, 
виконуючи операцію wait () і signal (). З іншого боку, блокування, придбане на об'єкті mutex, може 
бути звільнено лише процесом, який придбав блокування на об'єкті mutex.
/
Семафор мають два типи підрахунку семафора і двійкового семафора, який досить схожий на мьютекс.
/
Значення змінної Semaphore змінюється операцією wait () і signal (), крім ініціалізації. 
Однак об'єкт відключення звуку заблокований або розблокований процесом, який отримує або випускає ресурс.
----------------------------------------------------------------------------------------------------------
семафор что это?
/
Семафор є інструментом синхронізації процесів. Семафор, як правило, 
є цілочисельною змінною S, яка ініціалізується за кількістю ресурсів, присутніх у системі, 
і значення семафора може бути змінено тільки двома функціями wait () і signal (), крім ініціалізації.
/
Операція wait () і signal () змінюють значення семафора неподільно . Це означає, що коли процес змінює 
значення семафора, жоден інший процес не може одночасно змінювати значення семафора. Семафор виділяється 
операційною системою в двох категоріях: підрахунок семафорів і двійковий семафор .
/
У підрахунку семафорів значення семафора S ініціалізується за кількістю ресурсів, присутніх у системі. 
Всякий раз, коли процес хоче отримати доступ до ресурсу, він виконує операцію wait () на семафорі і зменшує 
значення семафора на одиницю. Коли він вивільняє ресурс, він виконує сигнал () на семафорі і збільшує 
значення семафора на одиницю. Коли кількість семафорів дорівнює 0, це означає, що всі ресурси зайняті 
процесами. Якщо процесу потрібно використовувати ресурс, коли лічильник семафора дорівнює 0, він виконує 
функцію wait () і блокується, поки значення семафора не стане більше 0.
/
У двійковому семафорі значення семафора коливається від 0 до 1 . 
Він схожий на блокування мьютекс, але мутекс є механізмом блокування, 
тоді як семафор є механізмом сигналізації. У двійковому семафорі, якщо 
процес хоче отримати доступ до ресурсу, він виконує операцію wait () на семафорі і 
зменшує значення семафора з 1 до 0. Коли він вивільняє ресурс, він виконує роботу сигналу 
() на семафорі і збільшує значення його значення до 1. Якщо значення семафора дорівнює 0 і процес 
хоче отримати доступ до ресурсу, він виконує операцію wait () і сам блокує, поки поточний процес, що 
використовує ресурси, вивільняє ресурс.
----------------------------------------------------------------------------------------------------------
что такое deadlock?
/
Взаимная блокировка (сокращённо взаимоблокировка, англ. deadlock) — ситуация в многозадачной среде
или СУБД, при которой несколько процессов находятся в состоянии ожидания ресурсов, занятых друг другом, 
и ни один из них не может продолжать свое выполнение.
/
Взаимная блокировка (deadlock) — явление, при котором все потоки находятся в режиме ожидания. 
Происходит, когда достигаются состояния:

- взаимного исключения: по крайней мере один ресурс занят в режиме неделимости и, следовательно, 
только один поток может использовать ресурс в любой данный момент времени.

- удержания и ожидания: поток удерживает как минимум один ресурс и запрашивает дополнительные ресурсов, 
которые удерживаются другими потоками.

- отсутствия предочистки: операционная система не переназначивает ресурсы: если они уже заняты, 
они должны отдаваться удерживающим потокам сразу же.

- цикличного ожидания: поток ждёт освобождения ресурса, другим потоком, который в свою очередь ждёт 
освобождения ресурса заблокированного первым потоком.
/
Простейший способ избежать взаимной блокировки – не допускать цикличного ожидания. Этого можно достичь,
получая мониторы разделяемых ресурсов в определённом порядке и освобождая их в обратном порядке.
----------------------------------------------------------------------------------------------------------
lock_guard  lock_guard<mutex> lm(mtx) // принимает параметором обьект мьютекса
/
это класс, задачей которой является захватить мьютекс в конструкторе(при создании обьекта такого класса)
и освободить этот мьютек в деструкторе, в тот момент, когда обьект этого класса будет покидать 
какую-то область видимости
----------------------------------------------------------------------------------------------------------
unique_lock  unique_lock<mutex> um(mtx) // принимает параметором обьект мьютекса 
и автоматически вызывает lock()
unique_lock<mutex> um(mtx, std::defer_lock) // принимает параметором обьект мьютекса и дефер_лок
и мы можем переходить на ручное управление то есть больше гибкости
можем не боятся забыть вызвать анлок потому что деструктор вызовет анлок автоматически с выхода
области видимости
/
тоже самое почти что и lock_guard, только есть ещё и методы которыми можно управлять и указывать
в каком месте и где залочить и разлочить (то есть, есть ручное управление, гибкий класс)
если мы передадим вторым параметром defer_lock, то снимается автоматическая синхронизация и мы можем
управлять обьектом unique_lock с методами lock() and unlock() в удобном нам месте
то есть с помощью unique_lock мы можем по разному манипулировать поведение мьютекса
----------------------------------------------------------------------------------------------------------
рекурсивный мьютекс
/
для рекурсивной функции для синхронизации
----------------------------------------------------------------------------------------------------------
Чи є С++ thread-safe?
/
Допустим, у тебя в библиотеке есть функция func. Для своих внутренних нужд функция работает с глобальной
переменной (т.е. в процессе работы сначала туда пишет, потом читает). Такая функция НЕ будет надёжно
работать внутри потоков. Если из двух потоков одновременно вызвали функцию func, то они будут обращаться 
к одной и той же глобальной переменной, при этом могут перебить значения друг другу. Говорят, что функция 
не является thread safe

Данное понятие характеризует, что объект суждения, к которому оно относится (код, функция, класс) 
безопасно при использовании в нескольких потоках. Это значит, что не будет data race, то есть либо 
там стоит синхронизация потоков, либо общие данные (если они есть) не изменяются.
----------------------------------------------------------------------------------------------------------
Data race?
+
Що таке race-condition?
/
Data race или состояние гонки — это ошибка проектирования многопоточной системы,
при которой работа программы зависит от порядка выполнения частей кода, которые не 
синхронизированы должным образом
Data race это состояние когда разные потоки обращаются к одной ячейке памяти без какой-либо 
синхронизации и как минимум один из потоков осуществляет запись.

Состояние гонки (англ. race condition), также конкуренция — ошибка проектирования многопоточной 
системы или приложения, при которой работа системы или приложения зависит от того, в каком порядке 
выполняются части кода. Своё название ошибка получила от похожей ошибки проектирования электронных схем
Race condition — это недостаток, возникающий, когда время или порядок событий влияют на правильность 
программы.
Важно, что Race condition — это семантическая ошибка.
----------------------------------------------------------------------------------------------------------
типы ошибок
/
Синтаксические ошибки
Эти эрроры не позволяют скомпилировать исходный код на компилируемых языках программирования.
Они обнаруживаются во время компиляции или интерпретации исходного кода. 
Они также могут быть легко обнаружены статическими анализаторами (линтами). Подробнее о линтах 
мы узнаем немного позже.
Синтаксические ошибки в основном вызваны нарушением ожидаемой формы или структуры языка, 
на котором пишется программа. Как пример, это может быть отсутствующая закрывающая скобка в уравнении.
/
Семантические ошибки
Отладка программы может потребоваться и по причине семантических ошибок, 
также известных как логические. Они являются наиболее сложными из всех, потому что не могут 
быть легко обнаружены. Признак того, что существует семантическая ошибка, – это когда программа 
запускается, отрабатывает, но не дает желаемого результата.
(код правильный, а не делает то что нужно)
/
Ошибки в процессе выполнения
Как и семантические, ошибки во время выполнения никогда не обнаруживаются при компиляции. 
В отличие от семантических ошибок, эти прерывают программу и препятствуют ее дальнейшему выполнению.
Они обычно вызваны неожиданным результатом некоторых вычислений в исходном коде.
----------------------------------------------------------------------------------------------------------
Які уникнути стану гонитви?
/
с помощью синхронизации mutex
----------------------------------------------------------------------------------------------------------
Що таке атомарна операція?
/
----------------------------------------------------------------------------------------------------------
Як працювати із std::mutex?
/
блокировать поток и разблокировать
синхронинизировать потоки с помощью мьютекса
----------------------------------------------------------------------------------------------------------
как избежать дедлока?
/
Всегда отпускайте захваченные мьютексы в обратном захвату порядке, т.е. 
руководствуйтесь логикой «первый захвачен – последний отпущен».
+
Всегда соблюдайте один и тот же порядок захвата мьютексов.
Если вы в одном потоке захватываете мьютекс 1, а затем мьютекс 2, то недопустимо захватывать их в ином 
порядке в другом потоке.
----------------------------------------------------------------------------------------------------------
/
----------------------------------------------------------------------------------------------------------
