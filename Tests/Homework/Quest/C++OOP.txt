Що таке клас?
/
Тип, определенный пользователем
------------------------------------------------------------------------------------------------------------
Які є основні типи даних у C++?
/
типы данных. определнные пользователем
типы данных встроенные
------------------------------------------------------------------------------------------------------------
Що таке інкапсуляція? Як вона реалізується в C++?
/
Инкапсуляция = сокрытие данных. Механизм позволяющий обьеденить данные, методы и их обработку в одну 
сущность - структуру или класс и защищает их от вмешательства от внешнего мира посредством модификатора
доступа.
Другими словами = сокрытия данных, запрещающая пользователю менять данные или код(процесс скрытого хранения 
деталей реализации обьекта)
------------------------------------------------------------------------------------------------------------
Які є вбудовані типи в С++?
/
bool = логический тип данных
/
символьные типы данных:
char
unsigned char
wchar_t
char16_t
char32_t
/
целочисленные типы данных
/
short
unsigned short
int
unsigned int
long
unsigned long
long long
unsigned long long
/
типы с плавающией точкой:
float
double
long double
/
тип без значения = void
------------------------------------------------------------------------------------------------------------
Що таке enum?
/
Перечесления, которому компилятором по умолчанию придается значение int
enum конвертируется в int без предупреждения, т.е. он фактически является int-типом.
------------------------------------------------------------------------------------------------------------
Як співвідноситься клас і об’єкт?
/
клас = описание обьекта(определяет тип обьекта), его поля и методы. поля - переменные. методы - для управления этими переменными
если класс это инструкция, то обьект это экземпляр класса

------------------------------------------------------------------------------------------------------------
Яка різниця між структурою і класом?
/
по умолчанию у структуры модификатор доступа public. А у класса private
так же и при наследовании, структура наследуется public. класс - private
------------------------------------------------------------------------------------------------------------
Різниця між private/protected/public та де вони використовуються?
/
это модификаторы доступа
Public — доступ открыт всем, кто видит определение данного класса.
Private — доступ открыт самому классу (т.е. функциям-членам данного класса) и друзьям (friend) данного класса, 
как функциям, так и классам.
Protected — доступ открыт классам, производным от данного.
/
При наследовании если отнаследоваться public, то все методы и члены в дочернем классе будут public
Если от protected все private остаются private, protected = protected, public = protected
Если от private = все члены и методы станоятся private
------------------------------------------------------------------------------------------------------------
Які методи класу є стандартними для класу?
/
Конструктор по умолчанию
Конструктор копирования
Операция присваивания с копированием
Деструктор
Конструктор переноса
Операция присваивания с переносом
------------------------------------------------------------------------------------------------------------
Що таке абстрактний клас і навіщо він?
/
абстрактний класс реализует концепцию абстракции.
это класс, экземпляр которого создать нельзя, и этот класс содержит как минимум одну чистую виртуальную функцию
Нужен он для реализции одного и тогоже поведения. Используется в полиморфизме.
(Абстрактный класс определяет интерфейс для переопределения производными классами.)
------------------------------------------------------------------------------------------------------------
Скільки займає пам’яті об’єкт порожнього класу class A{};?
/
1байт = это минимум.
------------------------------------------------------------------------------------------------------------
Що стане з функцією, якщо до неї додати ключове слово static? У контексті члена класу? 
У контексті методу класу?
/
Переменные внутри метода не обязательно будут static.
Создание и уничтожение экземпляров класса никак не затронет статический метод, 
его можно вызывать независимо от существования объектов класса. 
Это аналог обычной функции, только имя у неё необычное и область видимости.
Существование статического метода никак не отражается на том, как будет храниться объект класса.
Статические методы не имеют указателя this

------------------------------------------------------------------------------------------------------------
Які особливості статичних полів класу?
/
Статическое поле будет одно для всех экземпляров класса.
Статичні поля семантично не відрізняються від звичайних глобальних змінних, 
але вони доступні тільки по кваліфікованому імені (тобто із зазначенням імені класу), 
і тому, на відміну від глобальних змінних, 
не захаращують простір глобальних імен.
------------------------------------------------------------------------------------------------------------
Яка особливість константних методів-членів класу?
/
Константный метод — это метод, который гарантирует, 
что не будет изменять объект или вызывать неконстантные методы класса (поскольку они могут изменить объект).


------------------------------------------------------------------------------------------------------------
Як змінити поле класу в константному методі класу?
/
mutable
------------------------------------------------------------------------------------------------------------
Які методи можна викликати з константних об’єктів?
/
Якщо об'єкт класу оголошений з модифікаторм const,
Це означає, що для такого об'єкта можна викликати тільки константні методи
Правило: Робіть всі ваші методи, які не змінюють дані об’єкта класу, константними.
------------------------------------------------------------------------------------------------------------
Що таке купа та стек? Відмінності, принцип роботи.
/
купа - heap(куча)
Куча — это хранилище памяти, также расположенное в ОЗУ, которое допускает динамическое выделение памяти 
и не работает по принципу стека: это просто склад для ваших переменных. Когда вы выделяете в куче участок 
памяти для хранения переменной, к ней можно обратиться не только в потоке, но и во всем приложении. 
Именно так определяются глобальные переменные. По завершении приложения все выделенные участки памяти 
освобождаются. Размер кучи задаётся при запуске приложения, но, в отличие от стека, он ограничен лишь 
физически, и это позволяет создавать динамические переменные.
Вы взаимодействуете с кучей посредством ссылок, обычно называемых указателями — это переменные, 
чьи значения являются адресами других переменных. Создавая указатель, вы указываете на местоположение 
памяти в куче, что задаёт начальное значение переменной и говорит программе, где получить доступ к этому 
значению. Из-за динамической природы кучи ЦП не принимает участия в контроле над ней; в языках без сборщика
мусора (C, C++) разработчику нужно вручную освобождать участки памяти, которые больше не нужны.
Если этого не делать, могут возникнуть утечки и фрагментация памяти, что существенно замедлит работу кучи.
/
стек - автоматическая память.
Стек — это область оперативной памяти, которая создаётся для каждого потока. 
Он работает в порядке LIFO (Last In, First Out),  то есть последний добавленный в стек кусок памяти 
будет первым в очереди на вывод из стека. Каждый раз, когда функция объявляет новую переменную, 
она добавляется в стек, а когда эта переменная пропадает из области видимости 
(например, когда функция заканчивается), она автоматически удаляется из стека. 
Когда стековая переменная освобождается, 
эта область памяти становится доступной для других стековых переменных.
Кроме того, переменные, расположенные на стеке, всегда являются локальными.
/
Стек более быстрый.
Но у стека ограничен функционал.
------------------------------------------------------------------------------------------------------------
В чому різниця між вказівником та посиланням?
/
нельзя сделать массив ссылок, указателей можно
нету арифметики ссылок, указателей есть
нету смысла в int & const ref;
ссылку нельзя разыминовать
создать указатель можно пустной (nullptr)
ссылка обьязательна на что-то ссылаться
------------------------------------------------------------------------------------------------------------
Для чого потрібен вказівник на функцію? Як його оголосити?
/
Указатель на функцию (function pointer) хранит адрес функции. 
По сути указатель на функцию содержит адрес первого байта в памяти, по которому располагается 
выполняемый код функции. Самым распространенным указателем на функцию является ее имя. 
С помощью имени функции можно вызывать ее и получать результат ее работы.
/
обьявить ее можно
тип_возращаемого_значения (*имя_указателя)(список_параметров)
если 
int foo(int) - это функция
int (*ptr)(int) = foo ,  гдe ptr это - указатель
/
мысл очень простой - гибкость. Иногда нам заранее, в момент компиляции, точно неизвестно, 
какую именно функцию из нескольких однотипных мы захотим вызвать. 
Это становится известно непосредственно во время работы программы.
------------------------------------------------------------------------------------------------------------
Що буде, якщо забути викликати delete? Коли звільниться та пам’ять?
/
произойдет memory leak
------------------------------------------------------------------------------------------------------------
Що таке розумний вказівник? Які розумні вказівники є в стандартній бібліотеці?
/
смарт поинтер - класс, который имитирует указатель на обьект и добавляет необходимую новую функциональность
почему smart? при уничтожении указателя уничтожается обьект на который он указывает
/
auto_ptr = deleted in C++17
/
unique_ptr
Указатель нельзя копировать, но можно передавать владение им с помощью std::move    
/
share_ptr
Это значит, что где-то есть некая переменная, которая хранит количество указателей, 
которые ссылаются на объект. Если эта переменная становится равной нулю, то объект уничтожается
/
weak_ptr
это умный указатель, который содержит не владеющую («слабую») ссылку на объект, 
которым управляет std::shared_ptr . Он должен быть преобразован в std::shared_ptr для доступа 
к ссылочному объекту. проверяет живой ли обьект(с помощью share_ptr)
------------------------------------------------------------------------------------------------------------
Як працює std::unique_ptr?
/
Шаблонный класс unique_ptr представляет собой уникальный указатель на объект. 
Указатель нельзя копировать, но можно передавать владение им с помощью std::move. 
При уничтожении указателя автоматически вызывается деструктор объекта, на который он указывает 
------------------------------------------------------------------------------------------------------------
Як працює std::shared_ptr?
/
Это значит, что где-то есть некая переменная, которая хранит количество указателей, которые ссылаются 
на объект. Если эта переменная становится равной нулю, то объект уничтожается. 
Счетчик инкрементируется при каждом вызове либо оператора копирования либо оператора присваивания
------------------------------------------------------------------------------------------------------------
Розкажіть про константність змінної, посилання, вказівника? 
Що таке константний вказівник і вказівник на константу? Розмір вказівника в пам’яті?
/
Розмір вказівника в пам’яті = 8 байт
/
Що таке константний вказівник і вказівник на константу?
int * const ptr (константний вказівник) нельзя менять указатель на другие данные
const int *ptr (указатель на константу) нельзя менять значение по указателю, указатель может указывать
на другие данные
/
Розкажіть про константність змінної, посилання, вказівника? 
const int a = 10 // неменяемое значение
const int & a = // неменяемое значение
int & const a = // не имеет смысла
------------------------------------------------------------------------------------------------------------
Розкажіть про передачу аргументів за значенням, посиланням і вказівником?
/
по значению:
создается копия обьекта или переменной, и все манипуляции с ней не несут нагрузку на передаваемую переменную
по указателю:
передается адресс обьекта, что бы модифицировать обьект, его нужно разыминовать
по ссылке:
передается сам обьект
------------------------------------------------------------------------------------------------------------
Розкажіть про порядок обчислення аргументів функції?
/
Порядок вычисления аргументов в вызове функции — это пример неуточняемого поведения (англ. unspecified behavior). 
Такое поведение зависит от реализации (компилятора), но реализация свой выбор поведения документировать не должна.
Кстати говоря, порядок вычисления аргументов необязательно должен быть справа-налево или слева-направо. 
Более того, при вызове разных функций он может быть разным.
------------------------------------------------------------------------------------------------------------
Що трапиться, якщо повернути посилання на тимчасовий об’єкт?
/
обьект после локальной области видимости уничтожается и ссылка не сможет возвращать уничтоженный обьект.
------------------------------------------------------------------------------------------------------------
Що таке перевантаження функції? Види перевантаження.
/
в програмировании один из способов реализации полиморфизма(ad hoc), заключается в том, что можно
создавать несколько реализации функций(метода) с одним и тем же именем, но разной сигнатурой
------------------------------------------------------------------------------------------------------------
что нельзя перегружать
/

-> по поводу стрелочки уточнить

?: (тернарный оператор);
:: (доступ к вложенным именам);
. (доступ к полям);
.* (доступ к полям по указателю);
sizeof , typeid и операторы каста.
------------------------------------------------------------------------------------------------------------
Що таке явне та неявне приведення типів у С++? Розкажіть про функції явного приведення типів у C++?
/
неявное приведення типов - когда компилятор сам привидет один тип к другому.(не всегда возможно)
явное - когда пользователь говорит компилятору, что он хочет привести
/
в основном пользуются:
const_cast = снимает или добавляет константность, больше всего используют для снятия.
При этом, константным становится возвращаемое значение операции const_cast, а не сама переменная.
/
static_cast = говорит компилятору привести один тип в другой тип данных.
но она не должна быть использована для выполнения недопустимого преобразования, например, 
преобразование значения в указатель или наоборот.
рекомендуется использовать static_cast а не С преобразование, так как static_cast ограничивает недопустимое
привидение типов и считается безопасным
/
dynamic_cast = доступна только в C++ и имеет смысл только, применительно к членам класса иерархии «полиморфных типов»
Динамическое приведение типов данных может быть использовано для безопасного приведения указателя 
(или ссылки) на суперкласс, в указатель (или ссылку) на подкласс в иерархии классов. 
Если динамическое приведение типов — недопустимо, так как реальный тип объекта, указывает не на тот тип 
подкласса, приведение типов не выполнится.
Динамическое приведение указателя
При приведении указателя, в случае неудачи, dynamic_cast возвращает нулевой указатель nullptr. 
Такое поведение обеспечивает быстрый способ определения, является ли данный объект частностью 
динамического типа.
/
reinterpret_cast является наименее безопасной формой приведения типов данных в С++,
она позволяет интерпретировать значение в другой тип данных. reinterpret_cast не должна быть использована 
для приведения иерархии классов или преобразования константных переменных.
------------------------------------------------------------------------------------------------------------
Що таке ініціалізація змінної в if?
/
Это закономерное развитие уже имеющейся возможности, чтобы можно было объявлять так не только 
переменные с неявным кастом к bool, но и вообще любые. 
Очень полезно при следовании правилу минимально необходимой области видимости переменных.
------------------------------------------------------------------------------------------------------------
Що таке ліниві обчислення в С++?
/
применяемая в некоторых языках программирования стратегия вычисления, согласно которой вычисления 
следует откладывать до тех пор, пока не понадобится их результат. 
Ленивые вычисления относятся к нестрогим вычислениям.
/
bool A(){std::cout << " A "; return true;}
bool B(){std::cout << " B "; return false;}
bool C(){std::cout << " C "; return false;}
bool D(){std::cout << " D "; return false;}

int main(int argc, char* argv[])
{
    // if (A() && B() && C() && D())
    // {std::cout << "done";}
    
    if (A())
    {
        if (B())
        {
            if (C())
            {
                if (D())
                {
                    std::cout << "done";
                }
            }
        }
    }   
}
------------------------------------------------------------------------------------------------------------
Розкажіть про цикли for та range-for.
/
Создается локальная (auto) переменная it c типом char (тип элемента массива), 
в которую при прохождении цикла поочередно записывается каждое значение массива buf. 
Это новая форма записи циклов for (C++11).
/
Оператор for на основе диапазонов используется для создания циклов, которые должны выполняться по диапазону 
значений, т. е. любому набору значений, по которому возможны итерации, например std::vector или любая другая 
последовательность библиотеки STL, диапазон которой определен методами begin() и end(). Имя, объявленном в 
части for-range-declaration, является локальным для оператора for и не может быть объявлено в выражении 
(expression) или операторе (statement). Обратите внимание, что в части for-range-declaration этого оператора 
предпочтение отдано ключевому слову auto.
------------------------------------------------------------------------------------------------------------
Що робить ключове слово auto? auto-визначення return-типу, аргументів функції?
/
Що робить ключове слово auto - компилятор подставляет тип.
В С++11 auto позволяет не указывать тип переменной явно, говоря компилятору, чтобы он сам определил фактический 
тип переменной, на основе типа инициализируемого значения.
Это слово переопределено в новом стандарте и говорит компилятору: 
«Компилятор, возьми и угадай тип этой переменной!». Компилятор в многих случаях это может 
сам прекрасно сделать. Это удобно в шаблонах и для итераторов.
Ключевое auto слово направляет компилятору использовать выражение инициализации объявленной переменной 
или лямбда-параметра выражения, чтобы вывести его тип.
Начиная с C++11 ключевое слово auto может использоваться вместо типа переменной при инициализации 
для выполнения вывода типа. Во всех других случаях использования ключевого слова auto следует избегать, 
если на это нет веских причин.
------------------------------------------------------------------------------------------------------------
Чим відрізняються delete та delete[]? Що трапиться, коли викликати delete в об’єкта, створеного через new[]?
/
delete используется для очищения памяти после её выделения на куче для одичного типа.
delete [] = для массива
скорее всего произойдет утечка мапяти, так как мы освобождаем место мод один елемент, на памяти,
где выделено под массив. При потери указателя, пока программа не завершится, память не возможно освободить
------------------------------------------------------------------------------------------------------------
Обробка помилок у С++? Які конструкції використовують під час обробки exception?
/
try = область где возможно исключение
throw = генерация исключения
catch(...) = ловим исключения
------------------------------------------------------------------------------------------------------------
Чи можна викидати exception з конструктора? Які поля будуть сконструйовані, які поля будуть зруйновані?
/
Если конструктор класса завершает работу исключением, значит он не завершает свою работу — следовательно 
объект не будет создан. Из-за этого могут возникать утечки памяти, т.к. для не полностью сконструированных 
объектов не будет вызван деструктор. Из-за этого распространено мнение, что конструктор никогда не должен 
вырабатывать исключения, однако это не так — утечки памяти возникнут не во всех случаях.
------------------------------------------------------------------------------------------------------------
Що таке memory leak?
/
это неконтролируемое уменьшение свободной оперативной или виртуальной памяти компьютера. 
Причиной утечек становятся ошибки в программном коде.
------------------------------------------------------------------------------------------------------------
Чи можна викидати exception з деструктора?
/
Тем более очевидно, что если деструктор завершает работу исключением, то может возникать утечка памяти — 
в памяти могут остаться как части текущего класса, так и базовых классов. Из этого ясно, что деструктор 
никогда не должен вырабатывать исключения, а также обрабатывать все возможные исключения функций, которые 
вызывает — они могут приводить как к утечкам, так и к очень трудноуловимым ошибкам.
------------------------------------------------------------------------------------------------------------
Як відловити ділення на 0 в С++?
/
Чтобы обрабатывать его в стиле исключений С++, можно установить в Visual C++ параметр компилятора /EHa,
или установить фильтр необработанных исключений
------------------------------------------------------------------------------------------------------------
Що таке лямбда-функція у С++? Як отримати доступ до змінних у зовнішній ділянці видимості?
/
это так называемые анонимные функции
что бы обратится к функции по имени, можно воспользоватся auto
auto foo = ()[]{}
------------------------------------------------------------------------------------------------------------
Для чого використовувати namespace, anonymous namespace?
/
namespace = простраство имен, с помощью него мы можем явно указать с какого пространства имен
определенная переменная, если у неё аналогичное имя, то есть избеать конфликта имен
anonymous namespace = используют как область видимости одного файла, то есть внутреннее связывание
------------------------------------------------------------------------------------------------------------
Яе викликати об’єкт з nested namespace?
/
------------------------------------------------------------------------------------------------------------
Як працюють inline-функції? Чи може така функція бути рекурсивною?
/
в месте, где вызывается функция, подставляется её реализация.
inline ни в коем случае не может быть рекурсивной, так как будет подставлятся её реализации
------------------------------------------------------------------------------------------------------------
Що таке поліморфізм?
/
свойства програмного кода менять своё поведение в зависимости от технических задач(ситуации) возникающей при 
выполнении программ.
концепция в ООП которая позволяет получать разную реализацию(кода) за одним интерфейсом
есть полиморфизмы
(ad hoc = перегружать функции)
(параметризованый = выраженый в шаблонах)
(подтипов) (виртуальные методы)
------------------------------------------------------------------------------------------------------------
что такое интерфейс?
/
это класс, у которого все методы являются чистыми виртуальными функциями
Интерфейсы чрезвычайно популярны, так как они просты в использовании, удобны в поддержке,
и их функционал легко расширять
------------------------------------------------------------------------------------------------------------
Для чого використовується наслідування?
/
меньше кода
неповторять код
позволяет строить иерархии классов
механизм, который позволяет наследовать функциональность одного класса или базового класса (base class)
в другом - производном классе (derived class))
концепция ООП которая позволяет создавать новые классы на основании существующих
------------------------------------------------------------------------------------------------------------
Які бувають типи наслідування?
/
public = все поля и методы базового класса остаются в дочернем классе с такими модификаторами доступа
protected = все поля и методы базового класса private остаются private, protected остаться protected
public становятся protected в дочернем классе
private = все поля и методы базового класса становятся в дочернем классе private
------------------------------------------------------------------------------------------------------------
Для чого використовують віртуальне наслідування?
/
для решения проблемы ромбовидного наследования
------------------------------------------------------------------------------------------------------------
Як можна розв’язати проблему ромбоподібного наслідування без використання віртуального наслідування?
/
указать явно к какой переменной класса мы обращаемся
classA::i
------------------------------------------------------------------------------------------------------------
Що трапиться, якщо клас-спадкоємець передати за значенням у функцію, яка приймає базовий клас?
/
будут вызыватся методы базового класса
------------------------------------------------------------------------------------------------------------
Що трапиться, якщо успадкуватися від базового класу, який не має віртуального конструктора?
/
все будет ок, так как виртуальных конструкторов не существует
------------------------------------------------------------------------------------------------------------
Що трапиться, якщо викликати перевизначену virtual function з конструктора? 
Чи може конструктор бути віртуальним?
/
Теперь ответ на вопрос становится прост - виртуальный конструктор невозможен, так как на момент его вызова 
объекта ещё просто не существует - ещё даже не существует указателя.
компилятор скорее всего не поймет что делать, так как обьект еще не создался
------------------------------------------------------------------------------------------------------------
Чи може мати імплементацію pure virtual function?
Що трапиться, якщо викликати pure virtual function з конструктора?
/
Компилятор сойдет с ума, так как в конструкторе вызывается функция виртуальная, а обьект еще не создан
невалидная ссылка
------------------------------------------------------------------------------------------------------------
Які методи генеруються для класу за замовчуванням? В якому випадку такі методи не будуть генеруватися? 
Як змусити компілятор додати/видалити ці методи?
/
Конструктор по умолчанию (обычно не имеют параметров, но параметры могут быть по умолчанию)
Конструктор копирования
Деструктор
Операция присваивания с копированием
Конструктор переноса
Операция присваивания с переносом
/
что бы удалить или добавить используются ключевые слова default and delete
/
Конструктор, который не имеет параметров (или содержит параметры, которые все имеют значения по умолчанию), 
называется конструктором по умолчанию.
/
Хотя конструктор по умолчанию отлично подходит для обеспечения инициализации наших классов значениями 
по умолчанию, часто может быть нужно, чтобы экземпляры нашего класса имели определенные значения, 
которые мы предоставим позже. К счастью, конструкторы также могут быть объявлены с параметрами.
/
Конструктор копирования — это особый тип конструктора, который используется для создания нового объекта 
через копирование существующего объекта. И, как в случае с конструктором по умолчанию, если вы не 
предоставите конструктор копирования для своих классов самостоятельно, то язык C++ создаст public-конструктор
копирования автоматически. Поскольку компилятор мало знает о вашем классе, то по умолчанию созданный 
конструктор копирования будет использовать почленную инициализацию. Почленная инициализация означает, 
что каждый член объекта-копии инициализируется непосредственно из члена объекта-оригинала.
/
Оператор присваивания копированием (или «копирующее присваивание») используется для копирования одного 
класса в другой (существующий) класс. По умолчанию язык C++ автоматически предоставляет конструктор 
копирования и оператор присваивания копированием, если вы не предоставили их сами. Предоставляемые 
компилятором функции выполняют поверхностное копирование, что может вызывать проблемы у классов, которые 
работают с динамически выделенной памятью. Одним из вариантов решения таких проблем является переопределение 
конструктора копирования и оператора присваивания копированием для выполнения глубокого копирования.
/
В C++11 добавили две новые функции для работы с семантикой перемещения: конструктор перемещения
и оператор присваивания перемещением. В то время как цель семантики копирования состоит в том, 
чтобы выполнять копирование одного объекта в другой, цель семантики перемещения состоит в том, чтобы 
переместить владение ресурсами из одного объекта в другой (что менее затратно, чем выполнение операции 
копирования). Определение конструктора перемещения и оператора присваивания перемещением выполняется 
аналогично определению конструктора копирования и оператора присваивания копированием. Однако, в то время 
как функции с копированием принимают в качестве параметра константную ссылку l-value, функции с перемещением 
принимают в качестве параметра неконстантную ссылку r-value.
/
Правило: Если вам нужен конструктор перемещения и оператор присваивания перемещением, которые выполняют 
перемещение (а не копирование), то вам их нужно предоставить (написать) самостоятельно.
/
Конструктор перемещения и оператор присваивания перемещением вызываются, когда аргументом для создания 
или присваивания является r-value. Чаще всего этим r-value будет литерал или временное значение 
(временный объект).
/
В C++11 каждый класс, помимо конструктора по умолчанию, имеет следующие 5 дефолтных операций:

конструктор копирования (copy constructor);
оператор присваивания (copy assignment);
конструктор перемещения (move constructor);
оператор перемещения (move assignment);
деструктор (destructor).
При определении одной из этих 5-ти операций рекомендуется явно указать 
(либо определить, либо объявить с помощью default или delete) 
все остальные, т.к. все эти 5 операций тесно связаны. 
Это будет способствовать лучшему пониманию семантики класса при чтении кода.
Если явно определена одна из упомянутых 5-ти операций (в том числе с использованием default или delete), то:

недостающие операции копирования будут определены автоматически с поведением по умолчанию;
недостающие операции перемещения определены не будут.
Это следует учитывать при написании классов.
------------------------------------------------------------------------------------------------------------
Як заборонити успадковувати клас?
/
final
------------------------------------------------------------------------------------------------------------
Який порядок конструювання та руйнування класів в ієрархії? Порядок ініціалізації полів класу?
/
Дочерний метод вызывает конструктор базового класса. Если у нас есть иерахия A:public B : public C
то обьект класса С вызовет конструктор класса B. Конструктор класса В вызовет конструктор класса а
получится
А В С
при наличии виртуального деструктора
вызовется деструктор самого дочернего класса и по иерархии до базового
С В А
/
порядок инициализации полей класса
в порядке вызовов конструкторов
------------------------------------------------------------------------------------------------------------
Які є способи ініціалізації полів класу?
/
прямо в классе при обьявлении поля
до момента создания обьекта
можно в списке инициализации до тела конструктора с сигнатурой : а(а), и т.д.
можно в теле конструктора(только поля this класса)
------------------------------------------------------------------------------------------------------------
Чи може деструктор бути віртуальним?
/
Он обязан быть виртуальным если вы знаете что класс находится в иерархии
------------------------------------------------------------------------------------------------------------
Що робить ключове слово virtual?
/
это проявление полиморфизма подтипа
Спецификатор virtual создаёт виртуальную функцию. Виртуальная функция — это член базового класса, 
который может быть переопределён производным классом. Если функция не переопределяется производным классом, 
используется определение базового класса.
так же можно наследоваться с ключевым словом для решения проблемы ромбовидного наследования
------------------------------------------------------------------------------------------------------------
Для чого використовують віртуальний деструктор?
/
виртуальный деструктор преднозначен для вызова деструкторов дочерних классов в порядке иерархии
иначе будет мемори лик
смотрит тип обьекта и вызывает деструктор этого обьекта(обьекта дочернего класса)
------------------------------------------------------------------------------------------------------------
Що таке глибоке копіювання?
/
При глибокому копіюванні пам'ять спочатку виділяється для копіювання адреси, яку містить вихідний вказівник, 
а потім для копіювання фактичного значення. Таким чином копія знаходиться в окремій, 
від початкового значення, пам'яті і вони ніяк не впливають одна на одну.
------------------------------------------------------------------------------------------------------------
Що таке віртуальні функції та навіщо вони потрібні?
/
Віртуальна функція в мові С++ — це особливий тип функції, яка, при її виклику, виконує 
«найдочірніший» метод, який існує між батьківським і дочірніми класами. Ця властивість відома як поліморфізм.
------------------------------------------------------------------------------------------------------------
Як захистити об’єкт від копіювання?
/
= delete
------------------------------------------------------------------------------------------------------------
Що таке семантика переміщення?
/
предназначены для осуществления перемещения данных во время инициализации и конструирования новых объектов, 
что позволяет сократить издержки на копирование. Для практического осуществления семантики перемещения 
в синтаксис C++ введены rvalue ссылки, а также конструкторы перемещения и перемещающий оператор 
присваивания.
------------------------------------------------------------------------------------------------------------
/
------------------------------------------------------------------------------------------------------------