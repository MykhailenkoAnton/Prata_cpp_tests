З чого складається STL?
/
Алгоритмы
Итераторы
Контейнеры
Предикаты, Функторы
Алокаторы
----------------------------------------------------------------------------------------------------------
Які алгоритми застосовували з STL? 
В чому перевага використання алгоритмів перед власноруч написаними функціями?
/
алгоритми поиска, алгоритмы сортировки
std::find
std::for_each
std::sort
std::swap

Библиотека алгоритмов определяет функции для различных целей 
(например, поиск, сортировка, подсчёт, манипулирование), которые работают с диапазонами элементов. 

Алгоритм (в контексте STL) это функции которая работает с контейнером через итератор
потому что итераторы предоставляют абстракцию по отношению ко всем контейнерам

поэтому алгоиртмы работают с любыми типами данных, и с классами, если для класса предусмотрена
опреденная операция
----------------------------------------------------------------------------------------------------------
Розкажіть про контейнери стандартної бібліотеки vector, list, map, unordered_map.
/
vector - данимический массив под капотом(из минусов перевыделение памяти, капасити)
list - Двухсвязный список под капотом (узел указывает на следущий и предыдущий)
к примеру из плюсов это вставка в середину(так как меняются указатели)
map - хранит в себе ключ и значение, сложность - алгоритмическая
unordered_map - неупорядоченный контейнер, если мап отсортированн, то этот нет
----------------------------------------------------------------------------------------------------------
Які знаєте типи ітераторів? Чим вони відрізняються? В яких контейнерах використовуються?
/
Категории итераторов определяют действия которые можно сделать с итератором.
/
Итератор - шаблонный класс который имитирует указатель. Используется с контейнерами
интерфейс, предоставляющий доступ к элементам коллекции(контейнера) и навигацию по ним.
Класс(шаблон класса), который имитирует указатель на елементы контейнера
были придуманны что бы мы могли писать функции, которые работают со всеми контейнерами одинаков
Итератор — структура данных, которая «указывает» на некоторый элемент контейнера, 
и (для некоторых контейнеров) умеет переходить к предыдущему/следующему элементу.
/
для чтения	Читают значения с движением вперед. Могут быть инкрементированы, сравнены и разыменованы.

для записи	Пишут значения с движением вперед. Могут быть инкрементированы и разыменованы.

однонаправленные	Читают или пишут значения с движением вперед. 
Комбинируют функциональность предыдущих двух типов с возможностью сохранять значение итератора.
Прямые итераторы - это итераторы односвязных списков, например std::forward_list.

двунаправленные	Читают и пишут значения с движением вперед или назад. 
Похожи на однонаправленные, но их также можно инкрементировать и декрементировать.
Пример: итераторы двусвязных списков (std::list), деревьев (std::set).

с произвольным доступом	Читают и пишут значения с произвольным доступом. 
Самые мощные итераторы, сочетающие функциональность двунаправленных итераторов и возможность 
выполнения арифметики указателей и сравнений указателей.
Пример: итераторы массивов (std::vector), указатели.

обратные итераторы с произвольным доступом, или двунаправленные, движущиеся в обратном направлении.
----------------------------------------------------------------------------------------------------------
разница между set and map
/
set = ключ и есть значение (отсортированн) (только одик ключ, без дубликатов)
map = ключ и значение (отсортированн) (только одик ключ, без дубликатов)
unordered_multimap (ключи в произвольнов порядке)(могут иметь дубликаты)
----------------------------------------------------------------------------------------------------------
Що таке ідіома remove-erase?
/
с её помощью мы можем удалить определенные елементы, к примеру в векторе и сложность всегда будет О(n)
----------------------------------------------------------------------------------------------------------
Як отримати найменше значення типу?
/
----------------------------------------------------------------------------------------------------------
Яка різниця між std::map та std::hashmap?
/
std::map держит данные в отсортированном по ключу виде, в отличие от std::unordered_map. Если вам нужно 
это свойство, вам нужен std::map. Если нет, достаточно и std::unordered_map.
(Как следствие отсортированности, например, в std::map есть функция lower_bound, 
которой нет в std::unordered_map.)
----------------------------------------------------------------------------------------------------------
Як підрахувати кількість елементів у std::list?
/
std::list<T>::size()
----------------------------------------------------------------------------------------------------------
Що таке складність алгоритму та від чого вона залежить?
/
это время на выполнения Insert(вставка), Access(доступ к елементу), Erase(удаление), Search(поиск)

есть константная сложнось О(1)
алгоритмическая О(log n)
линейнай О(n)
и т.д.

к примеру доступ к елементу вектора будет константой сложностью, потому что arr(адресс первого елемента) + size
в независимости от количества елементов в векторе
----------------------------------------------------------------------------------------------------------
В чому різниця між vector та list і у яких випадках їх краще використовувати?
/
Нет, не правильно. В массиве данные хранятся последовательно. 
Доступ к произвольному элементу массива происходит быстрее, чем доступ к произвольному элементу списка.

а к примеру если нужно добавить елемент в центр массива, то лучше использовать лист.
так как идет перепривязка адрессов, а у вектора если капасити = сайз, то будет перевыделение +
конечно же смещение всех значений с правой стороны на одну позицию
/
vector:
динамический массив
Insert: Вставка O(1) push_back. another O(n) (амортизированая скорость)
Access: Доступ до елементу О(1)
Erase: Удаление O(1) pop_back. another O(n) (амортизированая скорость)
Search: поиск О(n) линейный поиск
у вектора есть операция перегруженная [], у листа = нету если много поиска, то лучше вектор

||

list:
Двухсвязный список
Insert: O(1) перепривязывание соседних адресов
Access: O(1) Доступ только по итератору(когда он есть). О(n) если нужно найти значение
Erase: O(1) перепривязывание соседних адресов
Search: O(n) линейный поиск
----------------------------------------------------------------------------------------------------------
/
----------------------------------------------------------------------------------------------------------